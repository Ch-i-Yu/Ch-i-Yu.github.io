<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Ch&#39;i YU">
    
    <title>
        
            A Haskell Walkthrough |
        
        Study with Ch&#39;i YU
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"ch-i-yu.github.io","root":"/","language":"en","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing, Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":false,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Study with Ch'i YU" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Study with Ch&#39;i YU
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                LINKS
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">LINKS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">A Haskell Walkthrough</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Ch&#39;i YU</span>
                        
                            <span class="author-label">Lv2</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-03-12 14:52:56</span>
        <span class="mobile">2022-03-12 14:52</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Walkthrough/">Walkthrough</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Haskell/">Haskell</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>19 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>Brief solutions of most chapters in <strong>Programming in Haskell</strong>.</p>
<blockquote>
<p>Hutton, G., 2007. Programming in Haskell, Cambridge, UK ; New York: Cambridge University Press.</p>
</blockquote>
<span id="more"></span>

<h3 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1 Introduction"></a>Chapter 1 Introduction</h3><ol>
<li><p>Give another possible calculation for the result of <code>double (double 2)</code>.</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Innermost Method:</span></span><br><span class="line"><span class="title">double</span> (double <span class="number">2</span>)</span><br><span class="line">= double (<span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">= (<span class="number">2</span> + <span class="number">2</span>) + (<span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">= <span class="number">4</span> + <span class="number">4</span></span><br><span class="line">= <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Outermost Method:</span></span><br><span class="line"><span class="title">double</span> (double <span class="number">2</span>)</span><br><span class="line">= (double <span class="number">2</span>) + (double <span class="number">2</span>)</span><br><span class="line">= (double <span class="number">2</span>) + (<span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">= (double <span class="number">2</span>) + <span class="number">4</span></span><br><span class="line">= (<span class="number">2</span> + <span class="number">2</span>) + <span class="number">4</span></span><br><span class="line">= <span class="number">4</span> + <span class="number">4</span></span><br><span class="line">= <span class="number">8</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>Show that <code>sum [x] = x</code> for any number <code>x</code>.</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum</span> [x]</span><br><span class="line">= x + sum []</span><br><span class="line">= x + <span class="number">0</span></span><br><span class="line">= x</span><br></pre></td></tr></table></figure>

</li>
<li><p>Define a function product that produces the product of a list of numbers, and show using your definition that <code>product [2,3,4] = 24</code>.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">product</span> [] = <span class="number">1</span></span><br><span class="line"><span class="title">product</span> (x:xs) = x * product xs</span><br><span class="line"><span class="comment">-------------------------------</span></span><br><span class="line"><span class="title">product</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">= <span class="number">2</span> * product [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">= <span class="number">2</span> * <span class="number">3</span> * product [<span class="number">4</span>]</span><br><span class="line">= <span class="number">2</span> * <span class="number">3</span> * <span class="number">4</span> * product []</span><br><span class="line">= <span class="number">2</span> * <span class="number">3</span> * <span class="number">4</span> * <span class="number">1</span></span><br><span class="line">= <span class="number">24</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>How should the definition of the function <code>qsort</code> be modified so that it produces a reverse sorted version of a list?</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">qsort&#x27;</span> :: <span class="type">Ord</span>(a) =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">qsort&#x27;</span> [] = []</span><br><span class="line"><span class="title">qsort&#x27;</span> (x:xs) = qsort&#x27; [a | a &lt;- xs, a &gt; x] ++ [x] ++ [b | b &lt;- xs, b &lt;= x]</span><br></pre></td></tr></table></figure>

</li>
<li><p>What would be the effect of replacing <code>&lt;=</code> by <code>&lt;</code> in the original definition of <code>qsort</code>? Hint: consider the example <code>qsort [2,2,3,1,1]</code></p>
<p><strong>A:</strong> Any duplicate elements&#x2F;items will be lost.<br>e.g. <code>qsort&#39;&#39; [2,2,3,1,1]</code> returns <code>[1, 2, 3]</code> only rather than <code>[1,1,2,2,3]</code>.</p>
</li>
</ol>
<hr>
<h3 id="Chapter-2-First-Steps"><a href="#Chapter-2-First-Steps" class="headerlink" title="Chapter 2 First Steps"></a>Chapter 2 First Steps</h3><ol>
<li><p><del>Work through the examples from this chapter using <strong>GHCi</strong>.</del></p>
<p> <em>Skipped.</em></p>
</li>
<li><p>Parenthesise the following numeric expressions:</p>
<p> <code>2 ^ 3 * 4</code> -&gt; <code>(2 ^ 3) * 4</code></p>
<p> <code>2 * 3 + 4 * 5</code> -&gt; <code>(2 * 3) + (4 * 5)</code></p>
<p> <code>2 + 3 * 4 ^ 5</code> -&gt; <code>2 + (3 * (4 ^ 5))</code></p>
</li>
<li><p>The script below contains three syntactic errors. Correct these errors and then check that your script works properly using <strong>GHCi</strong>.</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Original Script:</span></span><br><span class="line"><span class="type">N</span> = a &#x27;div&#x27; length xs</span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">          a = <span class="number">10</span></span><br><span class="line">         xs = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment">-- Fixed Script:</span></span><br><span class="line"><span class="title">n</span> = a `div` length xs</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">      a = <span class="number">10</span></span><br><span class="line">      xs = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment">-- Note:</span></span><br><span class="line"><span class="comment">-- 1. Function should start with lowercase letters;</span></span><br><span class="line"><span class="comment">-- 2. Use `(Same key for ~ on keyboard) nontation for a Function-Alias;</span></span><br><span class="line"><span class="comment">-- 3. Align the (1st letter of)variables, not the equations.</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>The library function last selects the last element of a non-empty list; for example, <code>last [1,2,3,4,5] = 5</code>. Show how the function <code>last</code> could be defined in terms of the other library functions introduced in this chapter. Can you think of another possible definition?</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- last :: [a] -&gt; a</span></span><br><span class="line"><span class="title">last&#x27;</span> xs = head (reverse xs)</span><br><span class="line"><span class="title">last&#x27;&#x27;</span> xs = head (drop (length xs - <span class="number">1</span>) xs)</span><br><span class="line"><span class="title">last&#x27;&#x27;&#x27;</span> xs = xs !! (length xs - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

</li>
<li><p>The library function <code>init</code> removes the last element from a non-empty list; for example, <code>init [1,2,3,4,5]</code> &#x3D; <code>[1,2,3,4]</code>. Show how <code>init</code> could similarly be defined in two different ways.</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- init :: [a] -&gt; [a]</span></span><br><span class="line"><span class="title">init&#x27;</span> xs = take (length xs - <span class="number">1</span>) xs</span><br><span class="line"><span class="title">init&#x27;&#x27;</span> xs = reverse (tail (reverse xs))</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="Chapter-3-Types-and-Classes"><a href="#Chapter-3-Types-and-Classes" class="headerlink" title="Chapter 3 Types and Classes"></a>Chapter 3 Types and Classes</h3><ol>
<li><p>What are the types of the following values?</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] :: [<span class="type">Char</span>]</span><br><span class="line">(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) :: (<span class="type">Char</span>, <span class="type">Char</span>, <span class="type">Char</span>)</span><br><span class="line">[(<span class="type">False</span>,&#x27;<span class="type">O&#x27;</span>),(<span class="type">True</span>,&#x27;<span class="number">1</span>&#x27;)] ::[(<span class="type">Bool</span>, <span class="type">Char</span>)]</span><br><span class="line">([<span class="type">False</span>,<span class="type">True</span>],[&#x27;<span class="number">0</span>&#x27;,&#x27;<span class="number">1</span>&#x27;]) :: ([<span class="type">Bool</span>], [<span class="type">Char</span>])</span><br><span class="line">[tail, init, reverse] :: [[<span class="type">Char</span>]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Write down definitions that have the following types; it does not matter what the definitions actually do as long as they are type correct.</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bools</span> :: [<span class="type">Bool</span>]</span><br><span class="line"><span class="title">bools</span> = [<span class="type">True</span>, <span class="type">False</span>, <span class="type">False</span>, <span class="type">True</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">nums</span> :: [[<span class="type">Int</span>]]</span><br><span class="line"><span class="title">nums</span> = [[<span class="number">1</span>], [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line"><span class="title">add&#x27;</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">add&#x27;</span> x y z = x + y + z</span><br><span class="line"></span><br><span class="line"><span class="title">copy&#x27;</span> :: a -&gt; (a, a)</span><br><span class="line"><span class="title">copy&#x27;</span> x = (x, x)</span><br><span class="line"></span><br><span class="line"><span class="title">apply&#x27;</span> :: (a -&gt; b) -&gt; a -&gt; b</span><br><span class="line"><span class="title">apply&#x27;</span> a b = a b</span><br></pre></td></tr></table></figure>

</li>
<li><p>What are the types of the following functions?</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">second</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">second</span> xs = head (tail xs)</span><br><span class="line"></span><br><span class="line"><span class="title">swap</span> :: (a,b) -&gt; (b,a)</span><br><span class="line"><span class="title">swap</span> (x,y) = (y,x)</span><br><span class="line"></span><br><span class="line"><span class="title">pair</span> :: a -&gt; b -&gt; (a, b)</span><br><span class="line"><span class="title">pair</span> x y = (x,y)</span><br><span class="line"></span><br><span class="line"><span class="title">exDouble</span> :: <span class="type">Num</span> a =&gt; a -&gt; a</span><br><span class="line"><span class="title">exDouble</span> x = x*<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="title">palindrome</span> :: <span class="type">String</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">palindrome</span> xs = reverse xs == xs</span><br></pre></td></tr></table></figure>

</li>
<li><p><del>Check your answers to the preceding three questions using <strong>GHCi</strong>.</del></p>
<p> <em>Skipped.</em></p>
</li>
<li><p>Why is it not feasible in general for function types to be instances of the <code>Eq</code> class? When is it feasible? </p>
<p> Hint: two functions of the same type are equal if they always return equal results for equal arguments.</p>
<p> <strong>A1:</strong> Their results may not be instances of the <code>Eq</code> class; It may be impossible to compare every pair of inputs and outputs in scope;<br> <strong>A2:</strong> Feasible if the functions return same type of instance of the <code>Eq</code> class, and the scope is limited with finite pairs of inputs and outputs.</p>
</li>
</ol>
<hr>
<h3 id="Chapter-4-Defining-Functions-WIP"><a href="#Chapter-4-Defining-Functions-WIP" class="headerlink" title="Chapter 4 Defining Functions(WIP)"></a>Chapter 4 Defining Functions(WIP)</h3><ol>
<li><p>Using library functions, define a function <code>halve :: [a] -&gt; ([a],[a])</code> that splits an even-lengthed list into two halves. For example:</p>
</li>
<li><p>Define a function <code>third :: [a] -&gt; a</code> that returns the third element in a list that contains at least this many elements using:</p>
</li>
<li><p>Consider a function <code>safetail :: [a] -&gt; [a]</code> that behaves in the same way as tail except that it maps the empty list to itself rather than producing an error. Using tail and the function <code>null :: [a] -&gt; Bool</code> that decides if a list is empty or not, define <code>safetail</code> using:</p>
</li>
<li><p>In a similar way to <code>&amp;&amp;</code> in section 4.4, show how the disjunction operator <code>||</code> can be defined in four different ways using pattern matching.</p>
</li>
<li><p>Without using any other library functions or operators, show how the meaning of the following pattern matching definition for logical conjunction <code>&amp;&amp;</code> can be formalised using conditional expressions:</p>
<p> Hint: use two nested conditional expressions.</p>
</li>
<li><p>Do the same for the following alternative definition, and note the difference in the number of conditional expressions that are required:</p>
</li>
<li><p>Show how the meaning of the following curried function definition can be formalised in terms of lambda expressions:</p>
</li>
<li><p>The Luhn algorithm is used to check bank card numbers for simple errors such as mistyping a digit, and proceeds as follows:</p>
</li>
</ol>
<hr>
<h3 id="Chapter-5-List-Comprehensions-WIP"><a href="#Chapter-5-List-Comprehensions-WIP" class="headerlink" title="Chapter 5 List Comprehensions(WIP)"></a>Chapter 5 List Comprehensions(WIP)</h3><hr>
<h3 id="Chapter-6-Recursive-Functions"><a href="#Chapter-6-Recursive-Functions" class="headerlink" title="Chapter 6 Recursive Functions"></a>Chapter 6 Recursive Functions</h3><ol>
<li><p>How does the recursive version of the factorial function behave if applied to a negative argument, such as <code>(-1)</code>? </p>
<p> Modify the definition to prohibit negative arguments by adding a guard to the recursive case.</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fact&#x27;</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">fact&#x27;</span> <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fact&#x27;</span> n | n &gt; <span class="number">0</span> = n * fact&#x27; (n - <span class="number">1</span>)</span><br><span class="line">        | otherwise error <span class="string">&quot;Cannot Applied to Negative Arguments&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Define a recursive function <code>sumdown :: Int -&gt; Int</code> that returns the sum of the non-negative integers from a given value down to zero. </p>
<p> For example, <code>sumdown 3</code> should return the result <code>3+2+1+0 = 6</code>.</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sumdown</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">sumdown</span> :: n | n &lt; <span class="number">0</span> = <span class="number">0</span></span><br><span class="line">             | n &gt; <span class="number">0</span> = n + sumdown (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Define the exponentiation operator <code>^</code> for non-negative integers using the same pattern of recursion as the multiplication operator <code>*</code>, and show how the expression <code>2 ^ 3</code> is evaluated using your definition.</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(^!) :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">m</span> ^! n | n &lt;= <span class="number">0</span> = <span class="number">1</span></span><br><span class="line">       | n &gt; <span class="number">0</span>  = m * (m *! (n - <span class="number">1</span>))</span><br><span class="line"><span class="comment">-------------------------------------------------</span></span><br><span class="line">(*!) :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">m</span> *! n | n &lt;= <span class="number">0</span> = <span class="number">0</span></span><br><span class="line">       | n &gt; <span class="number">0</span>  = m + (m *! (n - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>Define a recursive function <code>euclid :: Int -&gt; Int -&gt; Int</code> that implements Euclid’s algorithm for calculating the greatest common divisor of two non-negative integers: if the two numbers are equal, this number is the result; otherwise, the smaller number is subtracted from the larger, and the same process is then repeated. </p>
<p> For example:<br> <code>$ &gt; euclid 6 27</code></p>
<p> <code>$ &gt; 3</code></p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">euclid</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">euclid</span> m n | m &lt;= <span class="number">0</span>, n &lt;= <span class="number">0</span> = <span class="number">0</span></span><br><span class="line">           | m == m         = m</span><br><span class="line">           | m &lt; n          = euclid m (n - m)</span><br><span class="line">           | m &gt; n          = euclid (m - n) m</span><br></pre></td></tr></table></figure>
</li>
<li><p>Using the recursive definitions given in this chapter, show how <code>length [1,2,3]</code>, <code>drop 3 [1,2,3,4,5]</code>, and <code>init [1,2,3]</code> are evaluated.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">length</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">= <span class="number">1</span> + length [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">= <span class="number">1</span> + <span class="number">1</span> + length [<span class="number">3</span>]</span><br><span class="line">= <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + length []</span><br><span class="line">= <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">0</span></span><br><span class="line">= <span class="number">3</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="title">drop</span> <span class="number">3</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">= drop <span class="number">2</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">= drop <span class="number">1</span> [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">= drop <span class="number">0</span> [<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">= [<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="title">init</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">= [<span class="number">1</span>] ++ init [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">= [<span class="number">1</span>] ++ [<span class="number">2</span>] ++ init [<span class="number">3</span>]</span><br><span class="line">= [<span class="number">1</span>] ++ [<span class="number">2</span>] ++ []</span><br><span class="line">= [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>


</li>
<li><p>Without looking at the definitions from the standard prelude, define the following library functions on lists using recursion.</p>
<ul>
<li><p>Decide if all logical values in a list are True:<br>  <code>and :: [Bool] -&gt; Bool</code></p>
  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    and&#x27; :: [<span class="type">Bool</span>] -&gt; <span class="type">Bool</span></span><br><span class="line">    and&#x27; [] = <span class="type">True</span></span><br><span class="line">    and&#x27; (x:xs) = x &amp;&amp; and&#x27; xs </span><br><span class="line"></span><br><span class="line">- <span class="type">Concatenate</span> a list <span class="keyword">of</span> lists:</span><br><span class="line">    `concat :: [[a]] -&gt; [a]`</span><br><span class="line"></span><br><span class="line">    ```haskell</span><br><span class="line">    concat&#x27; :: [[a]] -&gt; [a]</span><br><span class="line">    concat&#x27; [] = []</span><br><span class="line">    concat&#x27; (x:xs) = x ++ concat&#x27; xs</span><br><span class="line"></span><br><span class="line">- <span class="type">Produce</span> a list with n identical elements:</span><br><span class="line">    `replicate :: <span class="type">Int</span> -&gt; a -&gt; [a]`</span><br><span class="line"></span><br><span class="line">    ```haskell</span><br><span class="line">    replicate&#x27; :: <span class="type">Int</span> -&gt; a -&gt; [a]</span><br><span class="line">    replicate&#x27; <span class="number">0</span> _ = [] </span><br><span class="line">    replicate&#x27; n x = x : replicate&#x27; (n - <span class="number">1</span>) x</span><br></pre></td></tr></table></figure>
</li>
<li><p>Select the nth element of a list:<br>  <code>(!!) :: [a] -&gt; Int -&gt; a</code></p>
  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    (!!!) :: [a] -&gt; <span class="type">Int</span> -&gt; a</span><br><span class="line">    (x:xs) :: <span class="number">0</span>                              = x</span><br><span class="line">    (x:xs) :: n | n &gt; <span class="number">0</span>, n &lt; = length (x:xs) = xs !!! (n - <span class="number">1</span>)</span><br><span class="line">                | otherwise error <span class="string">&quot;Invalid Index&quot;</span></span><br><span class="line"></span><br><span class="line">- <span class="type">Decide</span> <span class="keyword">if</span> a value is an element <span class="keyword">of</span> a list:</span><br><span class="line">    `elem :: <span class="type">Eq</span> a =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span>`</span><br><span class="line"></span><br><span class="line">    ```haskell</span><br><span class="line">    elem&#x27; :: <span class="type">Eq</span> a =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line">    elem&#x27; _ []               = <span class="type">False</span></span><br><span class="line">    elem&#x27; a x:xs | a == x    = <span class="type">True</span></span><br><span class="line">                 | otherwise = elem&#x27; a xs</span><br></pre></td></tr></table></figure>

<hr>
<p>  Note: most of these functions are defined in the prelude using other library functions rather than using explicit recursion, and are generic functions rather than being specific to the type of lists.</p>
</li>
</ul>
</li>
<li><p>Define a recursive function <code>merge :: Ord a =&gt; [a] -&gt; [a] -&gt; [a]</code> that merges two sorted lists to give a single sorted list. </p>
<p> For example:<br> <code>$ &gt; merge [2,5,6] [1,3,4]</code> </p>
<p> <code>$ &gt; [1,2,3,4,5,6]</code></p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">merge&#x27;</span> :: <span class="type">Ord</span> a =&gt; [a] -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">merge&#x27;</span> [] [] = []</span><br><span class="line"><span class="title">merge&#x27;</span> xs [] = xs</span><br><span class="line"><span class="title">merge&#x27;</span> [] ys = ys</span><br><span class="line"><span class="title">merge&#x27;</span> (x:xs) (y:ys) | x &lt; y = x : merge&#x27; xs (y:ys)</span><br><span class="line">                     | otherwise = y : merge&#x27; (x:xs) ys</span><br></pre></td></tr></table></figure>
<hr>
<p> Note: your definition should not use other functions on sorted lists such as <code>insert</code> or <code>isort</code>, but should be defined using explicit recursion.</p>
</li>
<li><p>Using merge, define a function <code>msort :: Ord a =&gt; [a] -&gt; [a]</code> that implements merge sort, in which the empty list and singleton lists are already sorted, and any other list is sorted by merging together the two lists that result from sorting the two halves of the list separately. </p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">halve&#x27;</span> :: [a] -&gt; ([a], [a])</span><br><span class="line"><span class="title">halve&#x27;</span> xs = splitAt ((length xs) `div` <span class="number">2</span>) xs</span><br><span class="line"></span><br><span class="line"><span class="title">msort&#x27;</span> :: <span class="type">Ord</span> a =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">msort&#x27;</span> []  = []</span><br><span class="line"><span class="title">msort&#x27;</span> [x] = [x]</span><br><span class="line"><span class="title">msort&#x27;</span> xs  = merge (sortMerge (fst (halve2 xs))) (sortMerge (snd (halve2 xs))) </span><br><span class="line"><span class="comment">-------------------------------------------------------------------------</span></span><br><span class="line"><span class="title">msort&#x27;&#x27;</span> :: <span class="type">Ord</span> a =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">msort&#x27;&#x27;</span> [] = []</span><br><span class="line"><span class="title">msort&#x27;&#x27;</span> [a] = [a]</span><br><span class="line"><span class="title">msort&#x27;&#x27;</span> xs = merge (msort&#x27;&#x27; (firstHalf xs)) (msort&#x27;&#x27; (secondHalf xs))</span><br><span class="line"></span><br><span class="line"><span class="title">firstHalf</span>  xs = <span class="keyword">let</span> &#123; n = length xs &#125; <span class="keyword">in</span> take (div n <span class="number">2</span>) xs</span><br><span class="line"></span><br><span class="line"><span class="title">secondHalf</span> xs = <span class="keyword">let</span> &#123; n = length xs &#125; <span class="keyword">in</span> drop (div n <span class="number">2</span>) xs</span><br></pre></td></tr></table></figure>

<p> Hint: first define a function <code>halve :: [a] -&gt; ([a],[a])</code> that splits a list into two halves whose lengths differ by at most one.</p>
</li>
<li><p>Using the five-step process, construct the library functions that:</p>
<ul>
<li><p>Calculate the sum of a list of numbers</p>
  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum&#x27;</span> :: <span class="type">NUM</span> a =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">sum&#x27;</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">sum&#x27;</span> (x:xs) = x + sum&#x27; xs</span><br></pre></td></tr></table></figure>
</li>
<li><p>Take a given number of elements from the start of a list;</p>
  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    takes&#x27; :: <span class="type">Int</span> -&gt; [a] -&gt; [a]</span><br><span class="line">    takes&#x27; <span class="number">0</span> xs = []</span><br><span class="line">    takes&#x27; _ [] = []</span><br><span class="line">    takes&#x27; n (x:xs) | n &lt; <span class="number">0</span>  = []</span><br><span class="line">                   | n &gt;= <span class="number">0</span> = x: takes&#x27; (n - <span class="number">1</span>) xs</span><br><span class="line"></span><br><span class="line">- <span class="type">Select</span> the last element <span class="keyword">of</span> a non-empty list.</span><br><span class="line"></span><br><span class="line">    ```haskell</span><br><span class="line">    last&#x27; :: [a] -&gt; a</span><br><span class="line">    last&#x27; [x] = x</span><br><span class="line">    last&#x27; (x:xs) = last&#x27; xs</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="Chapter-7-Higher-Order-Functions"><a href="#Chapter-7-Higher-Order-Functions" class="headerlink" title="Chapter 7 Higher-Order Functions"></a>Chapter 7 Higher-Order Functions</h3><ol>
<li><p>Show how the list comprehension <code>[f x | x &lt;- xs, p x] </code>can be re-expressed using the higher-order functions <code>map</code> and <code>filter</code>.</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">filmap</span> :: [a] -&gt; (a -&gt; <span class="type">Bool</span>) -&gt; (a -&gt; b) -&gt; [b]</span><br><span class="line"><span class="title">filmap</span> xs p f = map f (filter p xs)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Without looking at the definitions from the standard prelude, define the following higher-order library functions on lists:</p>
<p> Note: in the prelude the first two of these functions are generic functions rather than being specific to the type of lists.</p>
<ul>
<li><p>Decide if all elements of a list satisfy a predicate:<br>  <code>all :: (a -&gt; Bool) -&gt; [Bool] -&gt; Bool</code></p>
  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Recursive Method</span></span><br><span class="line"><span class="title">all&#x27;</span> p [] = <span class="type">True</span></span><br><span class="line"><span class="title">all&#x27;</span> p (x:xs) = (p x) &amp;&amp; (all&#x27; p xs)</span><br><span class="line"><span class="comment">-- Advanced Method</span></span><br><span class="line"><span class="title">all&#x27;&#x27;</span> p = map and p</span><br></pre></td></tr></table></figure>
</li>
<li><p>Decide if any element of a list satisfies a predicate:<br>  <code>any :: (a -&gt; Bool) -&gt; [Bool] -&gt; Bool</code></p>
  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Recursive Method</span></span><br><span class="line"><span class="title">any&#x27;</span> p [] = <span class="type">False</span></span><br><span class="line"><span class="title">any&#x27;</span> p (x:xs) = (p x) || (any&#x27; p xs)</span><br><span class="line"><span class="comment">-- Advanced Method</span></span><br><span class="line"><span class="title">any&#x27;&#x27;</span> p = map or p</span><br></pre></td></tr></table></figure>
</li>
<li><p>Select elements from a list while they satisfy a predicate:<br>  <code>takeWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code></p>
  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Recursive Method</span></span><br><span class="line"><span class="title">takeWhile&#x27;</span> _ [] = []</span><br><span class="line"><span class="title">takeWhile&#x27;</span> p (x:xs) | p x       = x : takeWhile&#x27; p xs</span><br><span class="line">                    | otherwise = []</span><br></pre></td></tr></table></figure>
</li>
<li><p>Remove elements from a list while they satisfy a predicate:<br>  <code>dropWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code></p>
  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Recursive Method</span></span><br><span class="line"><span class="title">dropWhile&#x27;</span> _ [] = []</span><br><span class="line"><span class="title">dropWhile&#x27;</span> p (x:xs) | p x         = dropWhile&#x27; p xs</span><br><span class="line">                      | otherwise = x : xs</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Redefine the functions <code>map f</code> and <code>filter p</code> using <code>foldr</code>.</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Lamda Calculus Method</span></span><br><span class="line"><span class="title">maps&#x27;</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">maps&#x27;</span> f = foldr (\x xs -&gt; f x : xs) []</span><br><span class="line"></span><br><span class="line"><span class="title">filters&#x27;</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">filters&#x27;</span> :: foldr (\x xs -&gt; <span class="keyword">if</span> p x <span class="keyword">then</span> x : xs <span class="keyword">else</span> xs) []</span><br></pre></td></tr></table></figure>

</li>
<li><p>Using <code>foldl</code>, define a function<code>dec2int :: [Int] -&gt; Int</code>that converts a decimal number into an integer. </p>
<p> For example:<br> <code>$ &gt; dec2int [2,3,4,5]</code></p>
<p> <code>$ &gt; 2345</code></p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">dec2int</span> :: [<span class="type">Int</span>] -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">dec2int</span> = foldl (\x y -&gt; <span class="number">10</span> * x + y) <span class="number">0</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>Without looking at the definitions from the standard prelude, define the higher-order library function <code>curry</code> that converts a function on <strong>pairs</strong> into a curried function, and, conversely, the function <code>uncurry</code> that converts a curried function with <strong>two arguments</strong> into a function on pairs. </p>
<p> Hint: first write down the types of the two functions.</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">curry</span> :: ((a, b) -&gt; t) -&gt; a -&gt; b -&gt; t</span><br><span class="line"><span class="title">curry</span> f = \x y -&gt; f (x, y)</span><br><span class="line"></span><br><span class="line"><span class="title">uncurry</span> :: (a -&gt; b -&gt; t) -&gt; (a, b) -&gt; t</span><br><span class="line"><span class="title">uncurry</span> f = \(x, y) -&gt; f x y</span><br></pre></td></tr></table></figure>

</li>
<li><p>A higher-order function unfold that encapsulates a simple pattern of recursion for producing a list can be defined as follows: </p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unfold</span> p h t x | p x = []</span><br><span class="line">               | otherwise = h x : unfold p h t (t x)</span><br></pre></td></tr></table></figure>

<p> That is, the function <code>unfold p h t </code>produces the empty list if the predicate <code>p</code> is true of the argument value, and otherwise produces a non-empty list by applying the function h to this value to give the head, and the function <code>t</code> to generate another argument that is recursively processed in the same way to produce the tail of the list.</p>
<p> For example, the function <code>int2bin</code> can be rewritten more compactly using unfold as follows: <code>int2bin = unfold (== 0) (‘mod‘ 2) (‘div‘ 2)</code></p>
<p> Redefine the functions <code>chop8</code>, <code>map f</code> and <code>iterate f</code> using unfold.</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">chop8</span> :: [<span class="type">Char</span>] -&gt; [[<span class="type">Char</span>]]</span><br><span class="line"><span class="title">chop8</span> = unfold (== []) (take <span class="number">8</span>) (drop <span class="number">8</span>) </span><br><span class="line"></span><br><span class="line"><span class="title">map&#x27;</span> :: <span class="type">Eq</span> b =&gt; (b -&gt; a) -&gt; [b] -&gt; [a]:t </span><br><span class="line"><span class="title">map&#x27;</span> f = unfold (== []) (f . head) (tail)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Iterate while True</span></span><br><span class="line"><span class="title">iterateTrue&#x27;</span> :: (<span class="type">Bool</span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> -&gt; [<span class="type">Bool</span>]</span><br><span class="line"><span class="title">iterateTrue&#x27;</span> f = unfold (== <span class="type">False</span>) id f</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Iterate while False</span></span><br><span class="line"><span class="title">iterateFalse&#x27;</span> :: (<span class="type">Bool</span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> -&gt; [<span class="type">Bool</span>]</span><br><span class="line"><span class="title">iterateFalse&#x27;</span> f = unfold (== <span class="type">True</span>) id f</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Note: id is an identity function of type a -&gt; a.</span></span><br><span class="line"><span class="comment">-- Note: dot (.) is the operator composes functions.</span></span><br><span class="line"><span class="comment">-- e.g. f (g x) == (f . g) x</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>Modify the binary string transmitter example to detect simple transmission errors using the concept of parity bits. That is, each eight-bit binary number produced during encoding is extended with a <strong>parity bit</strong>, set to one if the number contains an odd number of ones, and to zero otherwise. In turn, each resulting nine-bit binary number consumed during decoding is checked to ensure that its parity bit is correct, with the parity bit being discarded if this is the case, and a parity error being reported otherwise. </p>
<p> Hint: the library function <code>error :: String -&gt; a</code> displays the given string as an error message and terminates the program; the polymorphic result type ensures that error can be used in any context.</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Extend with Parity Bit</span></span><br><span class="line"><span class="title">enparify</span> :: [<span class="type">Int</span>] -&gt; [<span class="type">Int</span>]</span><br><span class="line"><span class="title">enparify</span> [] = []</span><br><span class="line"><span class="title">enparify</span> xs | even (sum xs) = xs ++ [<span class="number">0</span>]</span><br><span class="line">            | otherwise     = xs ++ [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Decode with Parity Bit</span></span><br><span class="line"><span class="title">deparify</span> :: [<span class="type">Int</span>] -&gt; [<span class="type">Int</span>]</span><br><span class="line"><span class="title">deparify</span> [] = []</span><br><span class="line"><span class="title">deparify</span> xs | even (sum (init xs)) &amp;&amp; (last xs == <span class="number">0</span>) = init xs</span><br><span class="line">            | odd (sum (init xs)) &amp;&amp; (last xs == <span class="number">1</span>)  = init xs</span><br><span class="line">            | otherwise                 = error <span class="string">&quot;Parity Error&quot;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>Test your new string transmitter program from the previous exercise using a faulty communication channel that forgets the first bit, which can be modelled using the <code>tail</code> function on lists of bits.</p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">parityTransmit</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">parityTransmit</span> [] = []</span><br><span class="line"><span class="title">parityTransmit</span> xs = map snd (filter (\(index, _) -&gt; index `mod` <span class="number">9</span> /= <span class="number">0</span>) $ zip [<span class="number">0</span>..] xs) </span><br></pre></td></tr></table></figure>

</li>
<li><p>Define a function <code>altMap :: (a -&gt; b) -&gt; (a -&gt; b) -&gt; [a] -&gt; [b]</code> that alternately applies its two argument functions to successive elements in a list, in turn about order.</p>
<p> For example:</p>
<p> <code>$ &gt; altMap (+10) (+100) [0,1,2,3,4]</code></p>
<p> <code> $ &gt; [10,101,12,103,14]</code></p>
 <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">altMap</span> :: (a -&gt; b) -&gt; (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">altMap</span> _ _ [] = []</span><br><span class="line"><span class="title">altMap</span> f _ (x0:[]) = f x0 : []</span><br><span class="line"><span class="title">altMap</span> f g (x0:x1:[]) = f x0 : g x1 : []</span><br><span class="line"><span class="title">altMap</span> f g (x0:x1:xs) = f x0 : g x1 : altMap f g xs</span><br></pre></td></tr></table></figure>

</li>
<li><p>Using <code>altMap</code>, define a function <code>luhn :: [Int] -&gt; Bool</code> that implements the Luhn algorithm from the exercises in chapter 4 for bank card numbers of any length. </p>
<p>Test your new function using your own bank card.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Pseudo-Code</span></span><br><span class="line"><span class="title">function</span> checkLuhn(string purportedCC) </span><br><span class="line">&#123;</span><br><span class="line">	int sum := integer(purportedCC[length(purportedCC)-<span class="number">1</span>])</span><br><span class="line">	int nDigits := length(purportedCC)</span><br><span class="line">	int parity := nDigits modulus <span class="number">2</span></span><br><span class="line">	for i from <span class="number">0</span> to nDigits - <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">    	int digit := integer(purportedCC[i])</span><br><span class="line">    	<span class="keyword">if</span> i modulus <span class="number">2</span> = parity</span><br><span class="line">        	digit := digit × <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> digit &gt; <span class="number">9</span></span><br><span class="line">			digit := digit - <span class="number">9</span></span><br><span class="line">        sum := sum + digit</span><br><span class="line">    &#125;</span><br><span class="line">    return (sum modulus <span class="number">10</span>) = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">--------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Haskell Solution</span></span><br><span class="line"><span class="title">luhnCalculus</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">luhnCalculus</span> x | x * <span class="number">2</span> &lt; <span class="number">9</span> = <span class="number">9</span></span><br><span class="line">               | otherwise = (x * <span class="number">2</span> - <span class="number">9</span>)</span><br><span class="line"><span class="title">luhn</span> xs | (sum (map luhnCalculus xs) mod <span class="number">10</span>) == <span class="number">0</span> = <span class="type">True</span></span><br><span class="line">        | otherwise = <span class="type">False</span>               </span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="Chapter-8-Declaring-Types-and-Classes"><a href="#Chapter-8-Declaring-Types-and-Classes" class="headerlink" title="Chapter 8 Declaring Types and Classes"></a>Chapter 8 Declaring Types and Classes</h3><hr>
<h3 id="Chapter-10-Interactive-Programming"><a href="#Chapter-10-Interactive-Programming" class="headerlink" title="Chapter 10 Interactive Programming"></a>Chapter 10 Interactive Programming</h3><hr>
<h3 id="Chapter-15-Lazy-Evaluation"><a href="#Chapter-15-Lazy-Evaluation" class="headerlink" title="Chapter 15 Lazy Evaluation"></a>Chapter 15 Lazy Evaluation</h3><hr>

        </div>

        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Haskell/">#Haskell</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/05/21/hello-world/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Hello World</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/03/08/Algorithm-I-Day-2-6/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Algorithm-I, Day 2-6</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Ch&#39;i YU</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-1-Introduction"><span class="nav-text">Chapter 1 Introduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-2-First-Steps"><span class="nav-text">Chapter 2 First Steps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-3-Types-and-Classes"><span class="nav-text">Chapter 3 Types and Classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-4-Defining-Functions-WIP"><span class="nav-text">Chapter 4 Defining Functions(WIP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-5-List-Comprehensions-WIP"><span class="nav-text">Chapter 5 List Comprehensions(WIP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-6-Recursive-Functions"><span class="nav-text">Chapter 6 Recursive Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-7-Higher-Order-Functions"><span class="nav-text">Chapter 7 Higher-Order Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-8-Declaring-Types-and-Classes"><span class="nav-text">Chapter 8 Declaring Types and Classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-10-Interactive-Programming"><span class="nav-text">Chapter 10 Interactive Programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-15-Lazy-Evaluation"><span class="nav-text">Chapter 15 Lazy Evaluation</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script>






<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
